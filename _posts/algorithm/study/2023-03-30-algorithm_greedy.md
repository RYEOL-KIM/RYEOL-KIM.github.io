---
title:  "[JAVA] 알고리즘 - [GREEDY] 짐 나르기 ⭐"

categories:
  - Programmers
tags:
  - [Algorithm, Coding Test]

toc: true
toc_sticky: true

date: 2023-03-30
last_modified_at: 2023-03-30
---

# 📌 [GREEDY] 짐 나르기

> 난이도 ⭐

<br>


## 🚀 (Greedy) 탐욕 알고리즘

> 선택의 순간마다 현재 상태에서의 최적의 해답만을 찾아 최종 해답에 도달하는 방법

<br>

![image](https://user-images.githubusercontent.com/124750905/228829733-6e665032-2c03-4392-a181-5a1b710ff2d2.png)

<br>

### 🔥 문제 해결 순서

1. 선택 절차 : 현재 상태에서의 최적의 해답을 선택


2. 적절성 검사 : 선택된 해가 문제의 조건을 만족하는지 검사


3. 해답 검사 : 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복

<br>

### 🔥 탐욕 알고리즘을 사용하기 위한 조건

1. 탐욕적 선택 속성(Greedy Choice Property)
  * 이전 선택과 다음 선택 간의 관계를 고려하지 않고도 각 단계에서 가장 최적의 선택을 하는 것
  * 알고리즘이 각 단계에서 최적의 선택을 하더라도 전체적으로 최적의 해결책을 구할 수 있음


2. 최적 부분 구조(Optimal Substructure)
  * 문제의 최적 해결책이 부분 문제의 최적 해결책을 포함하고 있다는 것
  * 전체 문제를 부분 문제로 나누어 해결할 수 있으며, 부분 문제의 최적 해결책을 이용하여 전체 문제의 최적 해결책을 구할 수 있다

만약 두 조건이 만족되지 않는다면, 탐욕 알고리즘은 최적해를 보장하지 않을 수 있다.

<br><br>

## 🚀 문제

> 박스에 짐을 담으려고 하는데 박스엔 짐을 최대 2개만 담을 수 있다
> 모든 짐을 옮기기 위해 필요한 박스 개수의 최소값을 구해야합니다

<br>

### 💡 탐욕 알고리즘 여부 판단

1. 탐욕적 선택 속성 여부
   : 이 문제에서 현재 단계에서 최적의 선택은 가장 무거운 짐과 가장 가벼운 짐을 선택하여 같이 넣을 수 있는지를 판단하는것이다. 이 판단을 반복하여 다음 단계에서도 최적의 선택을 할 수 있다.

2. 최적 부분 구조 여부
   : 이 문제에서는 최대한 적은 박스를 사용하여 모든 짐을 옮기려고 한다. 따라서, 무게가 작은 짐들을 우선적으로 처리하여 박스 개수를 최소화할 수 있다

### 💡 로직

- 1️⃣ 선택 절차 : 가장 무거운 짐과 가장 가벼운 짐을 선택
  - 이를 위해 입력값으로 들어온 짐의 배열을 정렬
- 2️⃣ 적절성 검사 : 두 짐을 박스에 넣을 수 있는지 판단
  - 넣을 수 있으면 두 짐을 박스에 포장 +1, 다음 최선을 선택(가벼운 쪽 +1, 무거운쪽 -1)
  - 넣을 수 없으면 무거운쪽만 -1하여 선택 (제일 무거운 짐은 상자에 포장 +1)
- 3️⃣ 집계된 박스값을 반환

<br>

### 💡 의사코드 작성

```java
// 모든 짐을 옮기기 위해 필요한 박스 개수의 최소값을 반환하는 함수
public int movingStuff(int[] stuff, int limit) {
// 최소, 최대 무게를 구하기 위해 배열을 정렬
// 최소, 최대 인덱스를 담을 변수와 포장된 박스 갯수를 담을 변수를 선언

// 가벼운 측이 무거운 측을 넘어서는 순간 종료되는 반복문 작성
// 현재 최소, 최대 무게의 합이 포장 무게한도 이하라면 
// 두 짐을 박스에 담고, 다음 최선책으로 넘어감
// 합이 포장 무게한도를 초과하면
// 가장 무거운 짐만 박스에 담고, 다음 최선책으로 넘어감

// 집계된 박스 갯수 리턴
```
<br>

### 🔥 의사코드를 사용하여 작성한 실제 코드

```java
// 모든 짐을 옮기기 위해 필요한 박스 개수의 최소값을 반환하는 함수
public int movingStuff(int[] stuff, int limit) {
  // 최소, 최대 무게를 구하기 위해 배열을 정렬
  Arrays.sort(stuff);
  // 최소, 최대 인덱스를 담을 변수와 포장된 박스 갯수를 담을 변수를 선언
  int left = 0;
  int right = stuff.length - 1;
  int boxes = 0;

  // 가벼운 측이 무거운 측을 넘어서는 순간 종료되는 반복문 작성
  while (left <= right) {
  // 현재 최소, 최대 무게의 합이 포장 무게한도 이하라면 
  if (stuff[left] + stuff[right] <= limit) {
  // 두 짐을 박스에 담고, 다음 최선책으로 넘어감
  boxes += 1;
  left += 1;
  right -= 1;
  // 합이 포장 무게한도를 초과하면
  } else {
  // 가장 무거운 짐만 박스에 담고, 다음 최선책으로 넘어감
  boxes += 1;
  right -= 1;
  }
  }
  // 집계된 박스 갯수 리턴
  return boxes;
  } 
```

<br><br>

### 🔥 레퍼런스 코드

* 위에서 내가 작성해본 코드는 실시간으로 비교대상을 변경하고 동시에 박스포장을 했으므로 '투 포인터 알고리즘'에 해당한다고 한다.
* 레퍼런스는 선택+적절성검사를 하며 2개의 짐이 들은 박스 수를 구하고 최대박스갯수(= 배열의 길이)에서 차감하는 식으로 구했다.
* 내가 구한 코드도 문제가 요구하는 답안을 통과했다. 하지만 이번엔 탐욕 알고리즘을 학습하고자 하는 시간이었다. 본래의 목적을 위해 레퍼런스 코드를 다시 살펴보면서 탐욕 알고리즘이 어떻게 쓰이는지 확인 해보자.

```java
public class Solution {
  public int movingStuff(int[] stuff, int limit) {
    int twoStuff = 0;
    // 짐을 무게순으로 오름차순 정렬
    Arrays.sort(stuff);
    // 가장 가벼운 짐의 인덱스
    int leftIdx = 0;
    // 가장 무거운 짐의 인덱스
    int rightIdx = stuff.length - 1;
    while(leftIdx < rightIdx) {
      // 가장 가벼운 짐과 무거운 짐의 합이 limit 보다 작거나 같으면 2개를 한번에 나를 수 있다
      if(stuff[leftIdx] + stuff[rightIdx] <= limit) {
        // 다음 짐을 확인하기 위해 가장 가벼운 짐과 무거운 짐을 가리키는 인덱스를 옮겨주고
        // 한번에 2개 옮길 수 있는 개수를 +1 해준다
        leftIdx++;
        rightIdx--;
        twoStuff++;
      } else {
        // 위 조건에 맞지 않는 경우는 한번에 한 개만 나를 수 있는 경우이기 때문에
        // 가장 무거운 짐의 인덱스만 옮겨준다
        rightIdx--;
      }
    }
    // 전체 짐의 개수에서 한번에 2개를 나를 수 있는 경우를 빼 주면 총 필요한 박스의 개수를 구할 수 있다
    return stuff.length - twoStuff;
  }
}

```
<br><br>

## 📌 Today I Learn

* 탐욕알고리즘은 문제를 해결할 때, 각 단계에서 가장 최적의 선택을 하는 알고리즘이다. 이러한 선택들이 모여서 전체적으로 최적의 해를 구할 수 있다.
  예를 들어, 한정된 자원을 이용해 최대한의 이득을 내는 문제를 해결할 때, 탐욕알고리즘은 현재 시점에서 가장 이득이 큰 선택을 계속해서 수행하면서 최적의 해를 구할 수 있다.

* 탐욕알고리즘은 매 순간 최적의 선택을 하고, 이전 선택이 이후 선택에 영향을 주지 않는 조건에서 사용할 수 있다.

* 탐욕알고리즘은 직관적이면서도 효율적이며, 다양한 문제에서 사용할 수 있다. 하지만, 모든 문제에 탐욕알고리즘을 적용할 수 있는 것은 아니다. 탐욕적 선택이 항상 최적의 선택임이 보장되지 않거나, 이전 선택이 이후 선택에 영향을 주는 경우에는 탐욕알고리즘을 사용하지 않는게 바람직하다.

* 탐욕알고리즘을 적용하기 전에는 문제의 특성을 분석하고, 탐욕적 선택이 최적의 선택임을 보장할 수 있는지 여부를 파악해야한다. 또한, 선택 구조를 정확히 파악하고 구현하는 것이 중요하다.

* 문제를 해결할 때 알고리즘이 적용될 수 있는지를 고민하고, 적절한 알고리즘을 선택하고 구현해야 하려는 노력을 해야한다.

<br><br>

***


    🌜 개인 공부 기록용 블로그입니다. 오류나 틀린 부분이 있을 경우 
    언제든지 댓글 혹은 메일로 지적해주시면 감사하겠습니다! 😄


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}